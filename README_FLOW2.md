# ターン処理の新方式実装プラン（Sequential方式）

## 概要

順次処理方式（Sequential）のターン処理システム。
各大名をランダム順序で処理し、コマンド決定→実行を逐次的に行う。
戦闘は発生時に即座に計算・演出・適用される。

## 設計思想

- 戦闘の順序を明確にする
- より「現実的な」ターン進行を実現
- 「先手番が有利」は許容（ランダム順序で平均化）
- AI大名の戦闘演出を全て見せる（スキップ機能あり）

---

## 処理フロー

```
[ターン開始]

S1. 全ての領地について
    Phase1. 税収・米生産
    Phase2. 維持費処理
    Phase3. ランダムイベント抽選
    Phase4. 領地の状態に反映
    → 次の領地へ

S2. 全ての生きている大名・将軍について
    Phase1. 健康処理
    Phase2. 年齢処理（新しい年のみ）
    Phase3. 死亡判定
    Phase4. 死亡演出（病死を明示）
    Phase5. 死亡結果を内部状態・勢力図に反映
    → 次の大名・将軍へ

S3. すべての生きている大名について（ランダム順序）
    Phase1/2. コマンド選択
        - 各領地につき1コマンドまで（内政・軍事合わせて）
        - 内政コマンド → 即反映
        - 軍事コマンド → 軍事コマンドリストに登録
    Phase3. 軍事コマンドリストの順次実行
        A. 攻撃 → 計算→演出→適用→死亡判定→勝利判定
        B. 徴兵 → 即反映
    → 次の大名へ

[ターン終了]
```

---

## コマンド制限ルール

### 1領地あたりのコマンド制限

```
各支配領地について:
  内政・軍事合わせて最大1コマンド

例:
  尾張: 開墾（内政） → OK
  尾張: 攻撃（軍事） → OK
  尾張: 開墾（内政）+ 攻撃（軍事） → NG（合わせて2つ）
  尾張: 開墾（内政）+ 米配布（内政） → NG（内政2つ）
  尾張: 徴兵（軍事）+ 攻撃（軍事） → NG（軍事2つ）
```

### 実装

- `province.command_used_this_turn` フラグ1つで管理
- コマンド実行後に `True` に設定
- ターン開始時に `reset_command_flag()` でリセット

---

## コマンド分類

### 内政コマンド（8種類）- 即時反映

| コマンド | 内部名 | 効果 |
|---------|--------|------|
| 開墾 | `cultivate` | 開発レベル+1、金-200 |
| 町開発 | `develop_town` | 町レベル+1、金-300 |
| 治水 | `flood_control` | 治水+20%、金-150 |
| 米配布 | `give_rice` | 忠誠度+10、米-100 |
| 兵士転送 | `transfer_soldiers` | 隣接領地へ兵士移動 |
| 金送付 | `transfer_gold` | 隣接領地へ金移動 |
| 米運搬 | `transfer_rice` | 隣接領地へ米移動 |
| 将軍配置 | `assign_general` | 武将を領地に配置 |

### 軍事コマンド（2種類）- リスト登録後に順次実行

| コマンド | 内部名 | 処理タイミング |
|---------|--------|--------------|
| 徴兵 | `recruit` | 軍事コマンドリストに登録 → Phase3で反映 |
| 攻撃 | `attack` | 軍事コマンドリストに登録 → Phase3で戦闘 |

---

## 軍事コマンドの実行

### 軍事コマンドリストの構造

```python
military_commands = [
    {
        "type": "attack",
        "province_id": 1,        # 出撃元領地
        "target_province_id": 2, # 攻撃対象領地
        "attack_force": 800,     # 攻撃兵力
        "general_id": 101        # 指揮武将
    },
    {
        "type": "recruit",
        "province_id": 3,        # 徴兵元領地
        "amount": 100            # 徴兵数
    }
]
```

### 実行順序

1. 大名がコマンドを選択した順に登録
2. 登録順に順次実行
3. 攻撃コマンド: 計算→演出→適用→死亡判定→勝利判定
4. 徴兵コマンド: 即時反映

---

## UI動作

### プレイヤーのコマンド入力

```
[ターン開始]
  ↓
S1（領地処理）、S2（キャラ処理）が自動実行
  ↓
S3 開始 → 大名がランダム順で処理
  ↓
AI大名の番 → 自動処理 → 戦闘演出
  ↓
プレイヤー大名の番が来たら:
  ★コマンド入力画面を表示★
  - 各領地をクリックしてコマンド選択
  - 1領地につき1コマンドまで
  ↓
プレイヤーが「行動決定」を押したら次の大名へ
```

### UI状態

| 状態 | 説明 |
|------|------|
| `waiting_player_input` | プレイヤーのコマンド入力待ち |
| `animating` | 演出中（コマンド入力不可） |
| `None` | ターン外 |

---

## 現行方式（Classic）との比較

| 項目 | Classic方式 | Sequential方式 |
|------|------------|----------------|
| **処理順序** | Phase 1-11を一括 | 領地→キャラ→大名順に逐次 |
| **戦闘計算** | 全戦闘を一括計算後に適用 | 1戦闘ごとに計算→演出→適用 |
| **先手有利性** | なし（同時計算） | あり（ランダム順で緩和） |
| **戦闘演出** | ターン末に一括 | 各大名の処理中に逐次 |
| **コマンド制限** | 1領地1コマンド | 1領地1コマンド（同じ） |

---

## 実装ファイル

- `core/turn_manager_v2.py` → `core/sequential_turn_manager.py`（リネーム予定）
- `config.py`: `TURN_PROCESSING_MODE = "sequential"`

---

## Generator/yieldパターン

UIとの非同期連携にPythonのgeneratorを使用:

```python
class SequentialTurnManager:
    def execute_turn(self) -> Generator:
        # S1: 領地処理
        yield from self._section_1_provinces()

        # S2: キャラクター処理
        yield from self._section_2_characters()

        # S3: 大名行動
        yield from self._section_3_daimyo_actions()
```

### yieldされるイベント

| イベント | 説明 |
|---------|------|
| `("turn_start", message)` | ターン開始メッセージ |
| `("message", text)` | AI大名のコマンド実行メッセージ |
| `("death_animation", data)` | 死亡演出 |
| `("battle_animation", data)` | 戦闘演出 |
| `("player_turn", daimyo_id)` | プレイヤーの番 |
| `("victory", None)` | 勝利 |
| `("game_over", None)` | ゲームオーバー |
